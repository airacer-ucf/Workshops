{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Below are the Workshop and GBM materials related to autonomous driving/racing for The AI Racer Grand Prix.</p> <p>(Will be updated as the workshops go on)</p>"},{"location":"#important-links","title":"Important Links","text":"<ul> <li>Join Us: https://tinyurl.com/airacer-join</li> <li>Competition &amp; Workshop Discord: https://tinyurl.com/airacer-discord</li> </ul>"},{"location":"#intro-to-ros-2-workshop-gbm-1","title":"Intro to ROS 2 - Workshop &amp; GBM 1","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<p>Before the Intro to ROS 2 Workshop, make sure to have Ubuntu 22.04 and ROS2 Humble installed on your machine. Below are some tutorial on how to install them:</p> <ul> <li>Install VMWare &amp; Ubuntu 22.04</li> <li>Install ROS2 Humble on Ubuntu 22.04</li> </ul>"},{"location":"#resources","title":"Resources","text":"<ul> <li>Presentation</li> <li>Workshop Guide</li> <li>Recording</li> </ul>"},{"location":"#simulation-automatic-emergency-braking-aeb-system-workshop-gbm-2","title":"Simulation &amp; Automatic Emergency Braking (AEB) System - Workshop &amp; GBM 2","text":""},{"location":"#prerequisites_1","title":"Prerequisites","text":"<p>Before this Workshop, make sure to have Ubuntu 22.04 and ROS2 Humble installed on your machine. Below are some tutorial on how to install them:</p> <ul> <li>Install VMWare &amp; Ubuntu 22.04</li> <li>Install ROS2 Humble on Ubuntu 22.04</li> </ul>"},{"location":"#resources_1","title":"Resources","text":"<ul> <li>Presentation</li> <li>Simulation Installation Guide</li> <li>Automatic Emergency Braking System Guide</li> <li>Recording</li> </ul> <p>Being familiar with using ROS 2 is highly recommended. See Intro to ROS 2 Workshop</p>"},{"location":"#pid-controller-wall-following-technique-workshop-gbm-3","title":"PID Controller &amp; Wall Following Technique - Workshop &amp; GBM 3","text":""},{"location":"#prerequisites_2","title":"Prerequisites","text":"<p>Before this Workshop, make sure to have Ubuntu 22.04 and ROS2 Humble installed on your machine, along with the F1Tenth Simulation. Below are some tutorial on how to install them:</p> <ul> <li>Install VMWare &amp; Ubuntu 22.04</li> <li>Install ROS2 Humble on Ubuntu 22.04</li> <li>Simulation Installation Guide</li> </ul>"},{"location":"#resources_2","title":"Resources","text":"<p>Being familiar with using ROS 2 is highly recommended. See Intro to ROS 2 Workshop</p>"},{"location":"#additional-resources","title":"Additional resources","text":"<ul> <li>Short Promo Presentation: https://tinyurl.com/airacer-grandprix1-promo</li> <li>Competition Master Document: https://tinyurl.com/airacer-grandprix1-doc</li> <li>Workshops &amp; Competition Calendar: https://tinyurl.com/airacer-calendar</li> </ul>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/","title":"Intro to ROS 2 Workshop Manual","text":""},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#review-ros2-fundamentals","title":"Review ROS2 Fundamentals","text":""},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#key-concepts-review","title":"Key Concepts Review","text":"<p>Before starting the exercises, familiarize yourself with these core ROS2 concepts:</p> <ul> <li>Nodes: Independent processes that perform specific computations</li> <li>Topics: Named buses for asynchronous message passing between nodes</li> <li>Messages: Typed data structures exchanged over topics</li> <li>Publishers: Nodes that send messages to topics</li> <li>Subscribers: Nodes that receive messages from topics</li> <li>Workspace: Directory structure for organizing ROS2 packages</li> <li>Packages: Organizational units containing nodes, libraries, and configuration files</li> </ul>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#ros2-workspace-structure","title":"ROS2 Workspace Structure","text":"<pre><code>ros2_ws/\n\u251c\u2500\u2500 src/              # Source code for packages\n\u251c\u2500\u2500 build/            # Intermediate build files\n\u251c\u2500\u2500 install/          # Compiled binaries and libraries\n\u2514\u2500\u2500 log/              # Build and runtime logs\n</code></pre>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#part-0-environment-setup-workspace","title":"Part 0 - Environment Setup &amp; Workspace","text":""},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#objective","title":"Objective","text":"<p>Build and run a ROS 2 workspace.</p>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#tasks","title":"Tasks","text":"<ol> <li>Source your ROS 2 installation if not automatically done already:</li> </ol> <p><code>bash    source /opt/ros/humble/setup.bash</code> 2. Create and build a workspace:</p> <p><code>bash    mkdir -p ~/ros2_ws/src    cd ~/ros2_ws    colcon build    source install/setup.bash</code></p>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#checkpoint","title":"Checkpoint","text":"<ul> <li><code>ros2 pkg list</code> runs without errors</li> </ul>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#part-1-difficulty-2-publisher-subscriber-nodes","title":"Part 1 (Difficulty: 2) - Publisher &amp; Subscriber Nodes","text":""},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#objective_1","title":"Objective","text":"<p>Understand nodes, topics, and messages through hands-on implementation.</p>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#python-publisher-subscriber-implementation","title":"Python Publisher-Subscriber Implementation","text":""},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#step-1-create-python-package","title":"Step 1: Create Python Package","text":"<ol> <li> <p>In the ROS2 workspace you created, Navigate to the <code>src/</code> directory: <code>bash    cd ~/ros2_ws/src</code></p> </li> <li> <p>Create a Python package named <code>my_python_pkg</code> with dependencies on <code>rclpy</code> and <code>std_msgs</code>: <code>bash    ros2 pkg create my_python_pkg --build-type ament_python --dependencies rclpy std_msgs</code></p> <p><code>--build-type ament_python</code> specifies the build system of the package and that it will be a Python-based ROS 2 package.</p> <p><code>--dependencies rclpy std_msgs</code> specifies the dependencies the package requires:</p> <ul> <li><code>rclpy</code> is the Python client library for ROS 2, needed to write ROS 2 nodes in Python.</li> <li><code>std_msgs</code> is a package that provides standard message types, such as String, Int32, and Float64</li> </ul> </li> <li> <p>Examine the generated package structure and identify the purpose of each file/directory.</p> </li> </ol> <p>Generated Package Structure:</p> <pre><code>```bash\nmy_python_pkg/\n\u251c\u2500\u2500 package.xml # file containing meta information about the package\n\u251c\u2500\u2500 setup.py # containing instructions for how to install the package\n\u251c\u2500\u2500 setup.cfg # optional; can define entry_points and metadata instead of setup.py\n\u251c\u2500\u2500 resource/\n\u2502   \u2514\u2500\u2500 my_python_pkg # marker file for the package\n\u2514\u2500\u2500 my_python_pkg/ # a directory with the same name as your package, used by ROS 2 tools to find your package, contains __init__.py\n    \u2514\u2500\u2500 __init__.py # used to mark directories on disk as Python package directories\n```\n</code></pre>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#step-2-write-the-publisher-node","title":"Step 2: Write the Publisher Node","text":"<p>In the <code>my_python_pkg</code> folder, create a file named <code>simple_publisher.py</code>, which will be the publisher node.</p> <p>File: <code>~/ros2_ws/src/my_python_pkg/my_python_pkg/simple_publisher.py</code></p> <pre><code>import rclpy                          # Import ROS2 Python client library\nfrom rclpy.node import Node           # Import Node class to create a ROS2 node\nfrom std_msgs.msg import String       # Import standard String message\n\nclass SimplePublisher(Node):\n    def __init__(self):\n        # Initialize the node with the name 'simple_publisher'\n        super().__init__('simple_publisher')\n\n        # Create a publisher of message type: String; topic name: 'topic'\n        # And queue size: 10 (buffer size for outgoing messages)\n        self.publisher_ = self.create_publisher(String, 'ros2intro', 10)\n\n        # Create a timer that triggers 'timer_callback' every 1 second (1Hz)\n        # The timer allows us to publish messages at a fixed interval.\n        self.timer = self.create_timer(1.0, self.publish_message)  # 1 second interval\n\n        # Initialize a counter to keep track of how many messages we've sent\n        self.count = 0\n\n    def publish_message(self):\n        # Called every 1.0 second due to the timer.\n\n        # Create a new String message instance\n        msg = String()\n\n        # Set its data field to a friendly message including the counter\n        msg.data = f'Hello ROS 2: {self.count}'\n\n        # Publish the message to the topic\n        self.publisher_.publish(msg)\n\n        # Log output to the console so we see what is being published\n        self.get_logger().info(f'Publishing: \"{msg.data}\"')\n\n        # Increment counter for the next message\n        self.count += 1\n\ndef main(args=None):\n    # Initialize the ROS client library\n    rclpy.init(args=args)\n\n    # Create an instance of our publisher node\n    node = SimplePublisher()\n\n    # Keep the node running until it is killed, allowing callbacks (like the timer) to function\n    rclpy.spin(node)\n\n    # Once we exit spin (e.g., by pressing Ctrl+C), destroy the node\n    node.destroy_node()\n\n    # Shutdown ROS2 gracefully\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#step-3-write-the-subscriber-node","title":"Step 3: Write the Subscriber Node","text":"<p>Create the subscriber node as <code>simple_subscriber.py</code>.</p> <p>File: <code>~/ros2_ws/src/my_python_pkg/my_python_pkg/simple_subscriber.py</code></p> <pre><code>import rclpy                          # Import the ROS2 Python client library for initializing nodes and handling ROS-related operations\nfrom rclpy.node import Node           # Import the Node class, which serves as the base class for all ROS2 node implementations\nfrom std_msgs.msg import String       # Import the standard ROS2 String message type for sending and receiving text data\n\nclass SimpleSubscriber(Node):\n    def __init__(self):\n        # Initialize this class as a ROS2 node named 'simple_subscriber'\n        super().__init__('simple_subscriber')\n\n        # Create a subscription to a topic named 'topic' that publishes String messages.\n        # Arguments:\n        #   String: The message type the subscriber expects (std_msgs/String)\n        #   'topic': The name of the topic to subscribe to\n        #   self.listener_callback: The callback function that will be triggered when a new message arrives\n        #   10: The queue size (message buffer) if messages arrive faster than they can be processed\n        self.subscription = self.create_subscription(\n            String,\n            'ros2intro',\n            self.listener_callback,\n            10)\n\n        # This line doesn't do anything functionally; it simply prevents a linting or IDE warning about the subscription\n        # variable not being used. It's a common practice in ROS2 Python examples.\n        self.subscription\n\n    def listener_callback(self, msg):\n        # This callback function is triggered each time a new message is received from the 'topic'.\n        # 'msg' is a String message, so we access its data field to get the actual text content.\n        # We then use the node's built-in logging system to print the received data.\n        self.get_logger().info(f'Received: \"{msg.data}\"')\n\ndef main(args=None):\n    # Initialize the ROS2 client library, necessary before using any ROS2-related code\n    rclpy.init(args=args)\n\n    # Create an instance of the SimpleSubscriber node\n    node = SimpleSubscriber()\n\n    try:\n        # Spin the node, meaning this will block and process any incoming callbacks indefinitely\n        # until an external event (like Ctrl+C) interrupts the process.\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        # If the user presses Ctrl+C in the terminal, a KeyboardInterrupt exception is raised.\n        # Here, we simply pass to allow the program to proceed to the 'finally' block for cleanup.\n        pass\n    finally:\n        # Once we are done spinning or have been interrupted, we destroy the node to clean up resources.\n        node.destroy_node()\n        if rclpy.ok():  # Only shutdown if not already shutting down; Prevent \"shutdown already called\" on Ctrl-C\n           # Shut down the rclpy library, releasing all ROS2-related resources.\n           rclpy.shutdown()\n\n# The standard Python entry point for executable scripts.\n# If this script is run directly (e.g., 'python3 subscriber.py'), execute the main() function.\nif __name__ == '__main__':\n    main()\n</code></pre> <p>[!Note] The <code>try/except/finally</code> block is not strictly necessary, but it's considered good practice for graceful shutdown.</p>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#step-4-update-the-setup-configuration","title":"Step 4: Update the Setup Configuration","text":"<p>Modify <code>setup.py</code> to point to your nodes.</p> <p>File: <code>~/ros2_ws/src/my_python_pkg/setup.py</code></p> <pre><code>from setuptools import setup\n\npackage_name = 'my_python_pkg'\n\nsetup(\n    name=package_name,\n    version='0.0.0',\n    packages=[package_name],\n    install_requires=['setuptools'],\n    zip_safe=True,\n    maintainer='your_name',\n    maintainer_email='your_email@example.com',\n    description='A simple publisher and subscriber example in ROS 2',\n    license='Apache License 2.0',\n    tests_require=['pytest'],\n    entry_points={\n        'console_scripts': [\n            'simple_publisher = my_python_pkg.simple_publisher:main',\n            'simple_subscriber = my_python_pkg.simple_subscriber:main',\n        ],\n    },\n)\n</code></pre>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#step-5-build-and-source-the-package","title":"Step 5: Build and Source the Package","text":"<p>Go to the workspace root, build the package, and source it:</p> <pre><code>cd ~/ros2_ws\ncolcon build\nsource install/setup.bash\n</code></pre> <p>Replace <code>.bash</code> with the appropriate Shell if you are not using Bash Shell</p>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#step-6-run-the-nodes","title":"Step 6: Run the Nodes","text":"<p>In two separate terminals, run the publisher and subscriber:</p>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#terminal-1-publisher","title":"Terminal 1: Publisher","text":"<pre><code>source ~/ros2_ws/install/setup.bash\nros2 run my_python_pkg simple_publisher\n</code></pre>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#terminal-2-subscriber","title":"Terminal 2: Subscriber","text":"<pre><code>source ~/ros2_ws/install/setup.bash\nros2 run my_python_pkg simple_subscriber\n</code></pre>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#expected-output","title":"Expected Output","text":"<ul> <li>Publisher Terminal:</li> </ul> <p><code>bash   [INFO] [simple_publisher]: Publishing: \"Hello ROS 2: 0\"   [INFO] [simple_publisher]: Publishing: \"Hello ROS 2: 1\"   ...</code></p> <ul> <li>Subscriber Terminal:</li> </ul> <p><code>bash   [INFO] [simple_subscriber]: Received: \"Hello ROS 2: 0\"   [INFO] [simple_subscriber]: Received: \"Hello ROS 2: 1\"   ...</code></p>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#part-2-difficulty-1-ros-2-cli-introspection","title":"Part 2 (Difficulty: 1) - ROS 2 CLI Introspection","text":""},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#objective_2","title":"Objective","text":"<p>Learn how to debug and inspect live systems</p>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#tasks_1","title":"Tasks","text":"<p>With your nodes running, open a new terminal and execute:</p> <ol> <li> <p>List all active nodes: <code>bash    ros2 node list</code></p> </li> <li> <p>Get detailed information about a node: <code>bash    ros2 node info /simple_publisher    ros2 node info /simple_subscriber</code></p> </li> <li> <p>List all active topics: <code>bash    ros2 topic list</code></p> </li> <li> <p>Get information about the <code>ros2intro</code> topic: <code>bash    ros2 topic info /ros2intro</code></p> </li> <li> <p>Echo messages from the topic: <code>bash    ros2 topic echo /ros2intro</code></p> </li> <li> <p>Check the publishing rate: <code>bash    ros2 topic hz /ros2intro</code></p> </li> </ol>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#part-3-difficulty-4-custom-message-types","title":"Part 3 (Difficulty: 4) - Custom Message Types","text":""},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#overview","title":"Overview","text":"<p>Custom message types allow you to define your own data structures for communication between nodes. Instead of using only standard messages like String or Float32, you can create messages that bundle multiple fields together, making your code more organized and meaningful.</p>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#understanding-custom-messages","title":"Understanding Custom Messages","text":""},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#why-use-custom-messages","title":"Why Use Custom Messages?","text":"<p>Standard Message:</p> <pre><code># Publishing speed as a Float32\nspeed_msg = Float32()\nspeed_msg.data = 25.5\n</code></pre> <p>Custom Message:</p> <pre><code># Publishing complete vehicle state\nvehicle_msg = VehicleState()\nvehicle_msg.speed = 25.5\nvehicle_msg.steering_angle = 15.0\nvehicle_msg.throttle = 0.8\nvehicle_msg.timestamp = self.get_clock().now().to_msg()\n</code></pre> <p>Custom messages are more descriptive, organized, and maintainable for complex robotic applications.</p>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#creating-a-custom-message-step-by-step","title":"Creating a Custom Message - Step by Step","text":""},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#step-1-create-a-package-for-custom-messages","title":"Step 1: Create a Package for Custom Messages","text":"<p>It's best practice to create a separate package for custom messages so multiple packages can use them.</p> <pre><code>cd ~/ros2_ws/src\nros2 pkg create my_custom_msgs --build-type ament_cmake\n</code></pre> <p>Why <code>ament_cmake</code>? Message generation requires CMake build system, even if your nodes are in Python.</p>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#step-2-create-message-directory-and-file","title":"Step 2: Create Message Directory and File","text":"<pre><code>cd ~/ros2_ws/src/my_custom_msgs\nmkdir msg\n</code></pre> <p>Create your first custom message file:</p> <p>File: <code>~/ros2_ws/src/my_custom_msgs/msg/VehicleState.msg</code></p> <pre><code># VehicleState.msg\n# Custom message for vehicle state information\n\nfloat32 speed                  # Vehicle speed in m/s\nfloat32 steering_angle        # Steering angle in degrees\nfloat32 throttle              # Throttle position (0.0 to 1.0)\nbuiltin_interfaces/Time timestamp  # Timestamp of the measurement\n</code></pre> <p>Message Field Types: - Basic types: <code>bool</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>float32</code>, <code>float64</code>, <code>string</code> - Arrays: <code>float32[]</code> (dynamic), <code>float32[5]</code> (fixed size) - Other messages: <code>builtin_interfaces/Time</code>, <code>std_msgs/Header</code></p>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#step-3-update-packagexml","title":"Step 3: Update package.xml","text":"<p>Add the required dependencies to <code>~/ros2_ws/src/my_custom_msgs/package.xml</code>:</p> <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;?xml-model href=\"http://download.ros.org/schema/package_format3.xsd\" schematypens=\"http://www.w3.org/2001/XMLSchema\"?&gt;\n&lt;package format=\"3\"&gt;\n  &lt;name&gt;my_custom_msgs&lt;/name&gt;\n  &lt;version&gt;0.0.0&lt;/version&gt;\n  &lt;description&gt;Custom message types for ROS2 tutorial&lt;/description&gt;\n  &lt;maintainer email=\"student@example.com\"&gt;student&lt;/maintainer&gt;\n  &lt;license&gt;Apache License 2.0&lt;/license&gt;\n\n  &lt;buildtool_depend&gt;ament_cmake&lt;/buildtool_depend&gt;\n\n  &lt;!-- Add these dependencies for message generation --&gt;\n  &lt;build_depend&gt;rosidl_default_generators&lt;/build_depend&gt;\n  &lt;exec_depend&gt;rosidl_default_runtime&lt;/exec_depend&gt;\n  &lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt;\n\n  &lt;!-- Add dependency on builtin_interfaces for Time type --&gt;\n  &lt;depend&gt;builtin_interfaces&lt;/depend&gt;\n\n  &lt;test_depend&gt;ament_lint_auto&lt;/test_depend&gt;\n  &lt;test_depend&gt;ament_lint_common&lt;/test_depend&gt;\n\n  &lt;export&gt;\n    &lt;build_type&gt;ament_cmake&lt;/build_type&gt;\n  &lt;/export&gt;\n&lt;/package&gt;\n</code></pre>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#step-4-update-cmakeliststxt","title":"Step 4: Update CMakeLists.txt","text":"<p>Update <code>~/ros2_ws/src/my_custom_msgs/CMakeLists.txt</code>:</p> <pre><code>cmake_minimum_required(VERSION 3.8)\nproject(my_custom_msgs)\n\nif(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n  add_compile_options(-Wall -Wextra -Wpedantic)\nendif()\n\n# Find dependencies\nfind_package(ament_cmake REQUIRED)\nfind_package(rosidl_default_generators REQUIRED)\nfind_package(builtin_interfaces REQUIRED)\n\n# Declare the message files to generate code for\nrosidl_generate_interfaces(${PROJECT_NAME}\n  \"msg/VehicleState.msg\"\n  DEPENDENCIES builtin_interfaces\n)\n\nif(BUILD_TESTING)\n  find_package(ament_lint_auto REQUIRED)\n  ament_lint_auto_find_test_dependencies()\nendif()\n\nament_package()\n</code></pre>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#step-5-build-the-message-package","title":"Step 5: Build the Message Package","text":"<pre><code>cd ~/ros2_ws\ncolcon build --packages-select my_custom_msgs\nsource install/setup.bash\n</code></pre> <p>Expected Output:</p> <pre><code>Starting &gt;&gt;&gt; my_custom_msgs\nFinished &lt;&lt;&lt; my_custom_msgs [5.23s]\n\nSummary: 1 package finished [5.67s]\n</code></pre>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#step-6-verify-message-creation","title":"Step 6: Verify Message Creation","text":"<p>Check that your message was created:</p> <pre><code>ros2 interface show my_custom_msgs/msg/VehicleState\n</code></pre> <p>Expected Output:</p> <pre><code>float32 speed\nfloat32 steering_angle\nfloat32 throttle\nbuiltin_interfaces/Time timestamp\n        int32 sec\n        uint32 nanosec\n</code></pre>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#using-custom-messages-in-python-nodes","title":"Using Custom Messages in Python Nodes","text":""},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#step-1-update-python-package-dependencies","title":"Step 1: Update Python Package Dependencies","text":"<p>Update <code>~/ros2_ws/src/my_python_pkg/package.xml</code> to add the custom message dependency:</p> <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;?xml-model href=\"http://download.ros.org/schema/package_format3.xsd\" schematypens=\"http://www.w3.org/2001/XMLSchema\"?&gt;\n&lt;package format=\"3\"&gt;\n  &lt;name&gt;my_python_pkg&lt;/name&gt;\n  &lt;version&gt;0.0.0&lt;/version&gt;\n  &lt;description&gt;A simple publisher and subscriber example in ROS 2&lt;/description&gt;\n  &lt;maintainer email=\"student@example.com\"&gt;student&lt;/maintainer&gt;\n  &lt;license&gt;Apache License 2.0&lt;/license&gt;\n\n  &lt;depend&gt;rclpy&lt;/depend&gt;\n  &lt;depend&gt;std_msgs&lt;/depend&gt;\n  &lt;depend&gt;my_custom_msgs&lt;/depend&gt;  &lt;!-- Add this line --&gt;\n\n  &lt;test_depend&gt;ament_copyright&lt;/test_depend&gt;\n  &lt;test_depend&gt;ament_flake8&lt;/test_depend&gt;\n  &lt;test_depend&gt;ament_pep257&lt;/test_depend&gt;\n  &lt;test_depend&gt;python3-pytest&lt;/test_depend&gt;\n\n  &lt;export&gt;\n    &lt;build_type&gt;ament_python&lt;/build_type&gt;\n  &lt;/export&gt;\n&lt;/package&gt;\n</code></pre>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#step-2-create-custom-message-publisher","title":"Step 2: Create Custom Message Publisher","text":"<p>File: <code>~/ros2_ws/src/my_python_pkg/my_python_pkg/custom_publisher.py</code></p> <pre><code>import rclpy\nfrom rclpy.node import Node\nfrom my_custom_msgs.msg import VehicleState\nimport random\nimport math\n\nclass CustomPublisher(Node):\n    def __init__(self):\n        super().__init__('custom_publisher')\n\n        # Create publisher for custom message type\n        self.publisher_ = self.create_publisher(\n            VehicleState, \n            'vehicle_state', \n            10)\n\n        # Timer to publish at 2 Hz\n        self.timer = self.create_timer(0.5, self.publish_vehicle_state)\n\n        # Simulation variables\n        self.simulation_time = 0.0\n\n        self.get_logger().info('Custom Publisher started - Publishing VehicleState messages')\n\n    def publish_vehicle_state(self):\n        # Create custom message instance\n        msg = VehicleState()\n\n        # Simulate varying vehicle state\n        self.simulation_time += 0.5\n\n        # Speed varies between 10-30 m/s with some randomness\n        msg.speed = 20.0 + 10.0 * math.sin(self.simulation_time * 0.5) + random.uniform(-1, 1)\n\n        # Steering angle varies between -30 and +30 degrees\n        msg.steering_angle = 15.0 * math.sin(self.simulation_time * 0.3) + random.uniform(-2, 2)\n\n        # Throttle varies between 0.3 and 1.0\n        msg.throttle = 0.65 + 0.35 * math.sin(self.simulation_time * 0.4)\n\n        # Add timestamp\n        msg.timestamp = self.get_clock().now().to_msg()\n\n        # Publish the message\n        self.publisher_.publish(msg)\n\n        # Log the published data\n        self.get_logger().info(\n            f'Publishing VehicleState: '\n            f'speed={msg.speed:.2f} m/s, '\n            f'steering={msg.steering_angle:.2f}\u00b0, '\n            f'throttle={msg.throttle:.2f}'\n        )\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = CustomPublisher()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#step-3-create-custom-message-subscriber","title":"Step 3: Create Custom Message Subscriber","text":"<p>File: <code>~/ros2_ws/src/my_python_pkg/my_python_pkg/custom_subscriber.py</code></p> <pre><code>import rclpy\nfrom rclpy.node import Node\nfrom my_custom_msgs.msg import VehicleState\n\nclass CustomSubscriber(Node):\n    def __init__(self):\n        super().__init__('custom_subscriber')\n\n        # Create subscription for custom message type\n        self.subscription = self.create_subscription(\n            VehicleState,\n            'vehicle_state',\n            self.vehicle_state_callback,\n            10)\n\n        self.subscription  # prevent unused variable warning\n\n        self.get_logger().info('Custom Subscriber started - Listening for VehicleState messages')\n\n    def vehicle_state_callback(self, msg):\n        # Extract timestamp\n        timestamp_sec = msg.timestamp.sec + msg.timestamp.nanosec * 1e-9\n\n        # Analyze the vehicle state\n        speed_status = self.analyze_speed(msg.speed)\n        steering_status = self.analyze_steering(msg.steering_angle)\n        throttle_status = self.analyze_throttle(msg.throttle)\n\n        # Log received data with analysis\n        self.get_logger().info(\n            f'Received VehicleState:\\n'\n            f'  Speed: {msg.speed:.2f} m/s ({speed_status})\\n'\n            f'  Steering: {msg.steering_angle:.2f}\u00b0 ({steering_status})\\n'\n            f'  Throttle: {msg.throttle:.2f} ({throttle_status})\\n'\n            f'  Timestamp: {timestamp_sec:.2f}s'\n        )\n\n    def analyze_speed(self, speed):\n        \"\"\"Provide context about speed\"\"\"\n        if speed &lt; 15:\n            return \"SLOW\"\n        elif speed &lt; 25:\n            return \"MODERATE\"\n        else:\n            return \"FAST\"\n\n    def analyze_steering(self, angle):\n        \"\"\"Provide context about steering\"\"\"\n        if abs(angle) &lt; 5:\n            return \"STRAIGHT\"\n        elif abs(angle) &lt; 15:\n            return \"GENTLE TURN\"\n        else:\n            return \"SHARP TURN\"\n\n    def analyze_throttle(self, throttle):\n        \"\"\"Provide context about throttle\"\"\"\n        if throttle &lt; 0.4:\n            return \"LOW\"\n        elif throttle &lt; 0.7:\n            return \"MEDIUM\"\n        else:\n            return \"HIGH\"\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = CustomSubscriber()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#step-4-update-setuppy","title":"Step 4: Update setup.py","text":"<p>Update <code>~/ros2_ws/src/my_python_pkg/setup.py</code> to include the new executables:</p> <pre><code>from setuptools import setup\n\npackage_name = 'my_python_pkg'\n\nsetup(\n    name=package_name,\n    version='0.0.0',\n    packages=[package_name],\n    data_files=[\n        ('share/ament_index/resource_index/packages',\n            ['resource/' + package_name]),\n        ('share/' + package_name, ['package.xml']),\n    ],\n    install_requires=['setuptools'],\n    zip_safe=True,\n    maintainer='student',\n    maintainer_email='student@example.com',\n    description='A simple publisher and subscriber example in ROS 2',\n    license='Apache License 2.0',\n    tests_require=['pytest'],\n    entry_points={\n        'console_scripts': [\n            'simple_publisher = my_python_pkg.simple_publisher:main',\n            'simple_subscriber = my_python_pkg.simple_subscriber:main',\n            'custom_publisher = my_python_pkg.custom_publisher:main',\n            'custom_subscriber = my_python_pkg.custom_subscriber:main',\n        ],\n    },\n)\n</code></pre>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#step-5-build-and-test","title":"Step 5: Build and Test","text":"<pre><code>cd ~/ros2_ws\ncolcon build --packages-select my_python_pkg\nsource install/setup.bash\n</code></pre> <p>Terminal 1 - Run Custom Publisher:</p> <pre><code>source ~/ros2_ws/install/setup.bash\nros2 run my_python_pkg custom_publisher\n</code></pre> <p>Expected Output:</p> <pre><code>[INFO] [custom_publisher]: Custom Publisher started - Publishing VehicleState messages\n[INFO] [custom_publisher]: Publishing VehicleState: speed=20.45 m/s, steering=2.34\u00b0, throttle=0.78\n[INFO] [custom_publisher]: Publishing VehicleState: speed=24.23 m/s, steering=5.67\u00b0, throttle=0.85\n[INFO] [custom_publisher]: Publishing VehicleState: speed=28.91 m/s, steering=-1.23\u00b0, throttle=0.92\n[INFO] [custom_publisher]: Publishing VehicleState: speed=26.45 m/s, steering=-8.45\u00b0, throttle=0.88\n</code></pre> <p>Terminal 2 - Run Custom Subscriber:</p> <pre><code>source ~/ros2_ws/install/setup.bash\nros2 run my_python_pkg custom_subscriber\n</code></pre> <p>Expected Output:</p> <pre><code>[INFO] [custom_subscriber]: Custom Subscriber started - Listening for VehicleState messages\n[INFO] [custom_subscriber]: Received VehicleState:\n  Speed: 20.45 m/s (MODERATE)\n  Steering: 2.34\u00b0 (STRAIGHT)\n  Throttle: 0.78 (HIGH)\n  Timestamp: 1735411234.56s\n[INFO] [custom_subscriber]: Received VehicleState:\n  Speed: 24.23 m/s (MODERATE)\n  Steering: 5.67\u00b0 (GENTLE TURN)\n  Throttle: 0.85 (HIGH)\n  Timestamp: 1735411235.06s\n</code></pre>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#part-4-difficulty-3-launch-files-multi-node-systems","title":"Part 4 (Difficulty: 3) - Launch Files (Multi-Node Systems)","text":""},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#overview_1","title":"Overview","text":"<p>Launch files allow you to start multiple nodes simultaneously with a single command. Instead of opening multiple terminals and running each node individually, you can configure and launch your entire system at once. This is essential for complex robotic systems</p>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#understanding-launch-files","title":"Understanding Launch Files","text":""},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#why-use-launch-files","title":"Why Use Launch Files?","text":"<p>Without Launch Files:</p> <pre><code># Terminal 1\nros2 run my_python_pkg simple_publisher\n\n# Terminal 2\nros2 run my_python_pkg simple_subscriber\n\n# Terminal 3\nros2 run my_python_pkg custom_publisher\n\n# Terminal 4\nros2 run my_python_pkg custom_subscriber\n</code></pre> <p>With Launch Files:</p> <pre><code># Single terminal\nros2 launch my_python_pkg all_nodes_launch.py\n</code></pre>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#benefits-of-launch-files","title":"Benefits of Launch Files:","text":"<ul> <li>Start multiple nodes with one command</li> <li>Configure parameters for nodes</li> <li>Set remapping rules for topics</li> <li>Organize complex systems</li> <li>Reproducible system startup</li> <li>Easier testing and debugging</li> </ul>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#python-launch-files","title":"Python Launch Files","text":""},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#step-1-create-launch-directory","title":"Step 1: Create Launch Directory","text":"<pre><code>cd ~/ros2_ws/src/my_python_pkg\nmkdir launch\n</code></pre>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#step-2-create-simple-launch-file","title":"Step 2: Create Simple Launch File","text":"<p>File: <code>~/ros2_ws/src/my_python_pkg/launch/simple_nodes_launch.py</code></p> <pre><code>from launch import LaunchDescription\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    \"\"\"Launch simple publisher and subscriber nodes\"\"\"\n\n    return LaunchDescription([\n        # Launch simple publisher node\n        Node(\n            package='my_python_pkg',\n            executable='simple_publisher',\n            name='simple_publisher',\n            output='screen',\n            emulate_tty=True,\n        ),\n\n        # Launch simple subscriber node\n        Node(\n            package='my_python_pkg',\n            executable='simple_subscriber',\n            name='simple_subscriber',\n            output='screen',\n            emulate_tty=True,\n        ),\n    ])\n</code></pre> <p>Explanation of Parameters: - <code>package</code>: The ROS2 package containing the executable - <code>executable</code>: The name of the node executable (from setup.py entry_points) - <code>name</code>: The name the node will use (can override the node's internal name) - <code>output='screen'</code>: Display node output in the terminal - <code>emulate_tty=True</code>: Ensures colored output and proper formatting</p>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#step-3-create-custom-messages-launch-file","title":"Step 3: Create Custom Messages Launch File","text":"<p>File: <code>~/ros2_ws/src/my_python_pkg/launch/custom_nodes_launch.py</code></p> <pre><code>from launch import LaunchDescription\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    \"\"\"Launch custom message publisher and subscriber nodes\"\"\"\n\n    return LaunchDescription([\n        # Launch custom publisher node\n        Node(\n            package='my_python_pkg',\n            executable='custom_publisher',\n            name='custom_publisher',\n            output='screen',\n            emulate_tty=True,\n        ),\n\n        # Launch custom subscriber node\n        Node(\n            package='my_python_pkg',\n            executable='custom_subscriber',\n            name='custom_subscriber',\n            output='screen',\n            emulate_tty=True,\n        ),\n    ])\n</code></pre>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#step-4-create-comprehensive-launch-file-all-nodes","title":"Step 4: Create Comprehensive Launch File (All Nodes)","text":"<p>File: <code>~/ros2_ws/src/my_python_pkg/launch/all_nodes_launch.py</code></p> <pre><code>from launch import LaunchDescription\nfrom launch_ros.actions import Node\nfrom launch.actions import DeclareLaunchArgument, LogInfo\nfrom launch.substitutions import LaunchConfiguration\n\ndef generate_launch_description():\n    \"\"\"\n    Launch all publisher and subscriber nodes:\n    - Simple string message nodes\n    - Custom VehicleState message nodes\n    \"\"\"\n\n    return LaunchDescription([\n        # Log info message\n        LogInfo(msg=\"Starting all ROS2 tutorial nodes...\"),\n\n        # Simple Publisher (String messages)\n        Node(\n            package='my_python_pkg',\n            executable='simple_publisher',\n            name='simple_publisher',\n            output='screen',\n            emulate_tty=True,\n            parameters=[],\n        ),\n\n        # Simple Subscriber (String messages)\n        Node(\n            package='my_python_pkg',\n            executable='simple_subscriber',\n            name='simple_subscriber',\n            output='screen',\n            emulate_tty=True,\n            parameters=[],\n        ),\n\n        # Custom Publisher (VehicleState messages)\n        Node(\n            package='my_python_pkg',\n            executable='custom_publisher',\n            name='custom_publisher',\n            output='screen',\n            emulate_tty=True,\n            parameters=[],\n        ),\n\n        # Custom Subscriber (VehicleState messages)\n        Node(\n            package='my_python_pkg',\n            executable='custom_subscriber',\n            name='custom_subscriber',\n            output='screen',\n            emulate_tty=True,\n            parameters=[],\n        ),\n\n        LogInfo(msg=\"All nodes launched successfully!\"),\n    ])\n</code></pre>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#step-5-update-setuppy-to-include-launch-files","title":"Step 5: Update setup.py to Include Launch Files","text":"<p>File: <code>~/ros2_ws/src/my_python_pkg/setup.py</code></p> <pre><code>from setuptools import setup\nimport os\nfrom glob import glob\n\npackage_name = 'my_python_pkg'\n\nsetup(\n    name=package_name,\n    version='0.0.0',\n    packages=[package_name],\n    data_files=[\n        ('share/ament_index/resource_index/packages',\n            ['resource/' + package_name]),\n        ('share/' + package_name, ['package.xml']),\n        # Include launch files\n        (os.path.join('share', package_name, 'launch'), \n            glob(os.path.join('launch', '*launch.[pxy][yma]*'))),\n    ],\n    install_requires=['setuptools'],\n    zip_safe=True,\n    maintainer='student',\n    maintainer_email='student@example.com',\n    description='A simple publisher and subscriber example in ROS 2',\n    license='Apache License 2.0',\n    tests_require=['pytest'],\n    entry_points={\n        'console_scripts': [\n            'simple_publisher = my_python_pkg.simple_publisher:main',\n            'simple_subscriber = my_python_pkg.simple_subscriber:main',\n            'custom_publisher = my_python_pkg.custom_publisher:main',\n            'custom_subscriber = my_python_pkg.custom_subscriber:main',\n        ],\n    },\n)\n</code></pre>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#step-6-update-packagexml-for-launch-dependencies","title":"Step 6: Update package.xml for Launch Dependencies","text":"<p>File: <code>~/ros2_ws/src/my_python_pkg/package.xml</code></p> <p>Add these dependencies if not already present:</p> <pre><code>  &lt;exec_depend&gt;ros2launch&lt;/exec_depend&gt;\n  &lt;exec_depend&gt;launch&lt;/exec_depend&gt;\n  &lt;exec_depend&gt;launch_ros&lt;/exec_depend&gt;\n</code></pre> <p>Complete package.xml should look like:</p> <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;?xml-model href=\"http://download.ros.org/schema/package_format3.xsd\" schematypens=\"http://www.w3.org/2001/XMLSchema\"?&gt;\n&lt;package format=\"3\"&gt;\n  &lt;name&gt;my_python_pkg&lt;/name&gt;\n  &lt;version&gt;0.0.0&lt;/version&gt;\n  &lt;description&gt;A simple publisher and subscriber example in ROS 2&lt;/description&gt;\n  &lt;maintainer email=\"student@example.com\"&gt;student&lt;/maintainer&gt;\n  &lt;license&gt;Apache License 2.0&lt;/license&gt;\n\n  &lt;depend&gt;rclpy&lt;/depend&gt;\n  &lt;depend&gt;std_msgs&lt;/depend&gt;\n  &lt;depend&gt;my_custom_msgs&lt;/depend&gt;\n\n  &lt;!-- Launch file dependencies --&gt;\n  &lt;exec_depend&gt;ros2launch&lt;/exec_depend&gt;\n  &lt;exec_depend&gt;launch&lt;/exec_depend&gt;\n  &lt;exec_depend&gt;launch_ros&lt;/exec_depend&gt;\n\n  &lt;test_depend&gt;ament_copyright&lt;/test_depend&gt;\n  &lt;test_depend&gt;ament_flake8&lt;/test_depend&gt;\n  &lt;test_depend&gt;ament_pep257&lt;/test_depend&gt;\n  &lt;test_depend&gt;python3-pytest&lt;/test_depend&gt;\n\n  &lt;export&gt;\n    &lt;build_type&gt;ament_python&lt;/build_type&gt;\n  &lt;/export&gt;\n&lt;/package&gt;\n</code></pre>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#step-7-build-and-test-launch-files","title":"Step 7: Build and Test Launch Files","text":"<pre><code>cd ~/ros2_ws\ncolcon build --packages-select my_python_pkg\nsource install/setup.bash\n</code></pre>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#step-8-run-launch-files","title":"Step 8: Run Launch Files","text":"<p>Launch simple nodes only:</p> <pre><code>ros2 launch my_python_pkg simple_nodes_launch.py\n</code></pre> <p>Expected Output:</p> <pre><code>[INFO] [launch]: All log files can be found below /home/student/.ros/log/2024-01-02-12-34-56-789012-ubuntu-12345\n[INFO] [launch]: Default logging verbosity is set to INFO\n[INFO] [simple_publisher-1]: process started with pid [12346]\n[INFO] [simple_subscriber-2]: process started with pid [12347]\n[simple_publisher-1] [INFO] [1735411234.123456789] [simple_publisher]: Publishing: \"Hello ROS 2: 0\"\n[simple_subscriber-2] [INFO] [1735411234.123456789] [simple_subscriber]: Received: \"Hello ROS 2: 0\"\n[simple_publisher-1] [INFO] [1735411235.123456789] [simple_publisher]: Publishing: \"Hello ROS 2: 1\"\n[simple_subscriber-2] [INFO] [1735411235.123456789] [simple_subscriber]: Received: \"Hello ROS 2: 1\"\n</code></pre> <p>Launch custom message nodes only:</p> <pre><code>ros2 launch my_python_pkg custom_nodes_launch.py\n</code></pre> <p>Launch all nodes:</p> <pre><code>ros2 launch my_python_pkg all_nodes_launch.py\n</code></pre> <p>Expected Output:</p> <pre><code>[INFO] [launch]: All log files can be found below /home/student/.ros/log/2024-01-02-12-34-56-789012-ubuntu-12345\n[INFO] [launch]: Default logging verbosity is set to INFO\n[INFO] [launch.user]: Starting all ROS2 tutorial nodes...\n[INFO] [simple_publisher-1]: process started with pid [12346]\n[INFO] [simple_subscriber-2]: process started with pid [12347]\n[INFO] [custom_publisher-3]: process started with pid [12348]\n[INFO] [custom_subscriber-4]: process started with pid [12349]\n[INFO] [launch.user]: All nodes launched successfully!\n[simple_publisher-1] [INFO] [1735411234.123456789] [simple_publisher]: Publishing: \"Hello ROS 2: 0\"\n[simple_subscriber-2] [INFO] [1735411234.123456789] [simple_subscriber]: Received: \"Hello ROS 2: 0\"\n[custom_publisher-3] [INFO] [1735411234.567890123] [custom_publisher]: Publishing VehicleState: speed=22.45 m/s, steering=3.21\u00b0, throttle=0.78\n[custom_subscriber-4] [INFO] [1735411234.567890123] [custom_subscriber]: Received VehicleState:\n[custom_subscriber-4]   Speed: 22.45 m/s (MODERATE)\n[custom_subscriber-4]   Steering: 3.21\u00b0 (STRAIGHT)\n[custom_subscriber-4]   Throttle: 0.78 (HIGH)\n[custom_subscriber-4]   Timestamp: 1735411234.57s\n</code></pre> <p>To stop all nodes: Press <code>Ctrl+C</code> in the terminal</p>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#practice-multi-node-communication-system-data-processing-pipeline","title":"Practice: Multi-Node Communication System - Data Processing Pipeline","text":"<p>Design and implement a simple multi-node system with the following architecture:</p> <pre><code>[Sensor Node] --&gt; /raw_data --&gt; [Processing Node] --&gt; /processed_data --&gt; [Display Node]\n</code></pre>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#requirements","title":"Requirements:","text":"<ol> <li>Sensor Node: Publishes simulated or random sensor readings (e.g., temperature values, speed, etc..) to <code>/raw_data</code></li> <li>Processing Node: Subscribes to <code>/raw_data</code>, applies a simple transformation (e.g., Celsius to Fahrenheit, kilometers to miles, etc..), and publishes to <code>/processed_data</code></li> <li>Display Node: Subscribes to <code>/processed_data</code> and displays the results</li> <li>Custom Data Type: Create at least one custom data types to be used by one or more of the nodes</li> <li>Launch File: Create a launch file that runs all of the required nodes and set parameters if needed</li> </ol>"},{"location":"Intro-to-ROS-2/Intro_to_ROS_2_Workshop_Manual/#implementation-notes","title":"Implementation Notes:","text":"<ul> <li>You can implement this in Python or C++</li> <li>Create these nodes in your existing package or create a new package</li> <li>Use appropriate message types (e.g., <code>std_msgs/Float32</code> for numeric data)</li> </ul>"},{"location":"Intro-to-ROS-2/ros2-install/","title":"Installing ROS 2 Humble on Ubuntu 22.04","text":""},{"location":"Intro-to-ROS-2/ros2-install/#0-verify-ubuntu-version","title":"0. Verify Ubuntu Version","text":"<p>ROS 2 Humble officially supports Ubuntu 22.04.</p> <p>Open a terminal and run:</p> <pre><code>lsb_release -a\n</code></pre> <p>You should see:</p> <pre><code>Distributor ID: Ubuntu\nRelease:        22.04\n</code></pre> <p>If not, stop and fix your Ubuntu installation before continuing.</p>"},{"location":"Intro-to-ROS-2/ros2-install/#1-update-system-packages","title":"1. Update System Packages","text":"<p>Always start with a clean, updated system.</p> <pre><code>sudo apt update\nsudo apt upgrade -y\nsudo apt install -y curl software-properties-common\n</code></pre> <p>Reboot if the system asks you to.</p>"},{"location":"Intro-to-ROS-2/ros2-install/#2-enable-ubuntu-universe-repository","title":"2. Enable Ubuntu Universe Repository","text":"<p>ROS 2 packages are hosted in the universe repository.</p> <pre><code>sudo add-apt-repository universe\nsudo apt update\n</code></pre>"},{"location":"Intro-to-ROS-2/ros2-install/#3-add-the-ros-2-gpg-key","title":"3. Add the ROS 2 GPG Key","text":"<p>This step allows Ubuntu to trust ROS 2 packages.</p> <pre><code>sudo mkdir -p /etc/apt/keyrings\ncurl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key | \\\nsudo gpg --dearmor -o /etc/apt/keyrings/ros-archive-keyring.gpg\n</code></pre>"},{"location":"Intro-to-ROS-2/ros2-install/#4-add-the-ros-2-repository","title":"4. Add the ROS 2 Repository","text":"<p>This tells Ubuntu where to download ROS 2 from.</p> <pre><code>echo \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/ros-archive-keyring.gpg] \\\nhttp://packages.ros.org/ros2/ubuntu $(lsb_release -cs) main\" | \\\nsudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/null\n</code></pre> <p>Update package lists again:</p> <pre><code>sudo apt update\n</code></pre>"},{"location":"Intro-to-ROS-2/ros2-install/#5-install-ros-2-humble","title":"5. Install ROS 2 Humble","text":"<p>Install the desktop version (includes RViz, demos, and tools).</p> <pre><code>sudo apt install -y ros-humble-desktop\n</code></pre> <p>This works on x86_64 (Intel/AMD) and ARM64 (Apple Silicon).</p>"},{"location":"Intro-to-ROS-2/ros2-install/#6-install-development-tools","title":"6. Install Development Tools","text":"<p>These tools are required for building ROS 2 packages in later labs.</p> <pre><code>sudo apt install ros-dev-tools\n</code></pre>"},{"location":"Intro-to-ROS-2/ros2-install/#7-initialize-rosdep-required","title":"7. Initialize rosdep (Required)","text":"<p><code>rosdep</code> installs system dependencies for ROS packages.</p> <pre><code>sudo rosdep init\nrosdep update\n</code></pre> <p>If <code>rosdep init</code> says it already exists, that is OK.</p>"},{"location":"Intro-to-ROS-2/ros2-install/#8-source-ros-2","title":"8. Source ROS 2","text":"<p>You must source ROS every time you open a terminal. </p> <pre><code>source /opt/ros/humble/setup.bash\n</code></pre> <p>Replace <code>.bash</code> with your shell extension if you\u2019re not using bash. You can find out which shell you are using by running the command <code>echo $0</code>. That command shows the shell that was used to start the current session. Some examples are: <code>setup.bash</code>, <code>setup.sh</code>, <code>setup.zsh</code>.</p>"},{"location":"Intro-to-ROS-2/ros2-install/#source-ros-2-automatically-optional","title":"Source ROS 2 Automatically (Optional)","text":"<pre><code>echo \"source /opt/ros/humble/setup.bash\" &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre> <p>One important caution</p> <p>If you later install multiple ROS versions, auto-sourcing one distro can cause conflicts.</p> <p>In that case, you might:</p> <ul> <li> <p>Comment it out in .bashrc, or</p> </li> <li> <p>Source the one you want manually</p> </li> </ul> <p>For a single-distro setup, this is perfectly fine.</p>"},{"location":"Intro-to-ROS-2/ros2-install/#9-verify-ros-2-installation","title":"9. Verify ROS 2 Installation","text":""},{"location":"Intro-to-ROS-2/ros2-install/#check-that-ros-2-is-installed","title":"Check that ROS 2 is installed:","text":"<pre><code>ros2 --help\n</code></pre> <p>You should see output indicating ROS 2 is installed.</p>"},{"location":"Intro-to-ROS-2/ros2-install/#run-a-talkerlistener-test","title":"Run a Talker/Listener Test:","text":"<p>Open Terminal 1:</p> <pre><code>ros2 run demo_nodes_cpp talker\n</code></pre> <p>Open Terminal 2:</p> <pre><code>ros2 run demo_nodes_py listener\n</code></pre> <p>If messages appear in the listener, ROS 2 is working correctly.</p> <p>To stop the running nodes press <code>Ctrl + c</code></p>"},{"location":"Intro-to-ROS-2/ros2-install/#10-common-vmware-specific-notes","title":"10. Common VMware-Specific Notes","text":""},{"location":"Intro-to-ROS-2/ros2-install/#performance-tips","title":"Performance Tips","text":"<ul> <li> <p>Allocate at least:</p> </li> <li> <p>2 GB RAM (4+ GB recommended)</p> </li> <li>2 CPU cores (2+ recommended)</li> <li>Enable 3D acceleration in VMware settings</li> </ul>"},{"location":"Intro-to-ROS-2/ros2-install/#11-known-issues-fixes","title":"11. Known Issues &amp; Fixes","text":""},{"location":"Intro-to-ROS-2/ros2-install/#problem-ros2-command-not-found","title":"Problem: <code>ros2: command not found</code>","text":"<p>Fix:</p> <pre><code>source /opt/ros/humble/setup.bash\n</code></pre>"},{"location":"Intro-to-ROS-2/ros2-install/#problem-slow-vm","title":"Problem: Slow VM","text":"<p>Fix:</p> <ul> <li>Increase RAM/CPU in VMware</li> <li>Disable unnecessary Ubuntu startup apps</li> </ul>"},{"location":"Intro-to-ROS-2/ros2-install/#12-uninstalling-ros2-fyi-do-not-do-this-unless-needed","title":"12. Uninstalling ROS2 (FYI - DO NOT DO THIS UNLESS NEEDED)","text":"<p>If you ever need to remove ROS2 or switch to a source-based installation, use the following commands:</p> <pre><code>sudo apt remove ~nros-humble-* &amp;&amp; sudo apt autoremove\n</code></pre> <p>Additionally, remove the ROS2 repository:</p> <pre><code>sudo rm /etc/apt/sources.list.d/ros2.list\nsudo apt update\nsudo apt autoremove\n</code></pre> <p>(Optional: Consider upgrading packages that were previously shadowed by ROS2 installations.)</p> <pre><code>sudo apt upgrade\n</code></pre>"},{"location":"Intro-to-ROS-2/ros2-install/#12-summary-what-you-should-have-now","title":"12. Summary (What You Should Have Now)","text":"<ul> <li>Ubuntu 22.04</li> <li>ROS 2 Humble Desktop installed</li> <li>rosdep initialized</li> <li>ROS automatically sourced</li> <li>Verified with talker/listener</li> </ul>"},{"location":"Intro-to-ROS-2/vmware-ubuntu/","title":"Installing Ubuntu 22.04 on VMware virtual machine","text":"<p>Platforms: Windows, macOS (Intel chips), macOS (Apple Silicon chips)</p> <p>Note that for the purpose of our workshops, if you have <code>Ubuntu 22.04</code> installed through other methods, such as WSL, Other Virtual Machine, Dual Boot, or Native Ubuntu 22.04, then it is not necessary to use this Virtual Machine</p>"},{"location":"Intro-to-ROS-2/vmware-ubuntu/#objective","title":"Objective","text":"<p>In this tutorial, you will:</p> <ol> <li>Install VMware virtual machine on your computer</li> <li>Create a virtual machine (VM) environment</li> <li>Install Ubuntu 22.04</li> <li>Verify a working Ubuntu desktop environment</li> </ol>"},{"location":"Intro-to-ROS-2/vmware-ubuntu/#requirements","title":"Requirements","text":"<ul> <li>A computer running Windows, macOS (Intel), or macOS (Apple Silicon)</li> <li>At least 8 GB RAM recommended</li> <li>At least 50 GB free disk space</li> <li>Internet connection</li> </ul>"},{"location":"Intro-to-ROS-2/vmware-ubuntu/#step-1-install-vmware-differs-by-platform","title":"Step 1: Install VMware (Differs by Platform)","text":""},{"location":"Intro-to-ROS-2/vmware-ubuntu/#windows","title":"Windows","text":"<ul> <li>VMware product: VMware Workstation Pro (Free for personal use)</li> <li>Download from:   https://www.techpowerup.com/download/vmware-workstation-pro/</li> <li>Click on the <code>Download</code> button for Windows (This tutorial is tested on the <code>25H2</code> version, but feel free to try a newer version if available)</li> <li>Select a server to download it from, and the download should start automatically (the server closest to you is usually a good choice)</li> </ul> <p>Install steps:</p> <ol> <li>Run the downloaded <code>.exe</code></li> <li>Click Next</li> <li>Accept license agreement</li> <li>Use default options</li> <li>Click Install</li> <li>Restart if prompted</li> </ol>"},{"location":"Intro-to-ROS-2/vmware-ubuntu/#macos-intel-apple-silicon","title":"macOS (Intel &amp; Apple Silicon)","text":"<ul> <li>VMware product: VMware Fusion Pro (Free for personal use)</li> <li>Download from:   https://www.techspot.com/downloads/2755-vmware-fusion-mac.html</li> <li>From the download options, click on a version, and the download should start automatically (This tutorial is tested on the <code>25H2</code> version, but feel free to try a newer version if available)</li> </ul> <p>Install steps:</p> <ol> <li>Open the downloaded <code>.dmg</code></li> <li>Double click VMware Fusion or drag it to Applications (depends on installer)</li> <li>Launch VMware Fusion if not automatically launched</li> <li>Approve permissions in System Settings \u2192 Privacy &amp; Security \u2192 Accessibility</li> <li>Restart if requested</li> </ol> <p>VMware Fusion automatically installs the correct version for Intel or Apple Silicon Macs.</p>"},{"location":"Intro-to-ROS-2/vmware-ubuntu/#step-2-download-ubuntu-2204-critical-differences","title":"Step 2: Download Ubuntu 22.04 (Critical Differences)","text":""},{"location":"Intro-to-ROS-2/vmware-ubuntu/#windows-macos-intel","title":"Windows &amp; macOS Intel","text":"<p>Download Ubuntu 22.04 Desktop (amd64): https://releases.ubuntu.com/jammy/</p> <p>On the <code>Desktop image</code> section, click on <code>64-bit PC (AMD64) desktop image</code>, and the download should start automatically</p> <p>File name example:</p> <pre><code>ubuntu-22.04.x-desktop-amd64.iso\n</code></pre> <p>This is the official Ubuntu Desktop ISO.</p>"},{"location":"Intro-to-ROS-2/vmware-ubuntu/#macos-apple-silicon-chips","title":"macOS Apple Silicon Chips","text":"<p>Important: Ubuntu does not provide an official Desktop ARM ISO.</p> <p>Instead, download Ubuntu 22.04 Server (ARM): https://cdimage.ubuntu.com/releases/jammy/release/</p> <p>On the <code>Server install image</code> section, click on <code>64-bit ARM (ARMv8/AArch64) server install image</code>, and the download should start automatically</p> <p>File name example:</p> <pre><code>ubuntu-22.04.x-live-server-arm64.iso\n</code></pre> <p>You will install the desktop later.</p>"},{"location":"Intro-to-ROS-2/vmware-ubuntu/#step-3-create-the-virtual-machine","title":"Step 3: Create the Virtual Machine","text":""},{"location":"Intro-to-ROS-2/vmware-ubuntu/#windows-vmware-workstation-pro","title":"Windows (VMware Workstation Pro)","text":"<ol> <li>Open VMware Workstation Pro</li> <li>Click Create a New Virtual Machine</li> <li>Select Installer disc image file (iso)</li> <li>Browse to the Ubuntu ISO file you downloaded earlier</li> <li>Click Next</li> <li>Follow the recommended setting options</li> <li>Name the VM (e.g., <code>Ubuntu 22.04</code>)</li> <li> <p>Disk size:</p> </li> <li> <p>Recommended: 50 GB</p> </li> <li>Click Finish</li> </ol>"},{"location":"Intro-to-ROS-2/vmware-ubuntu/#macos-vmware-fusion-intel-apple-silicon","title":"macOS (VMware Fusion \u2013 Intel &amp; Apple Silicon)","text":"<ol> <li>Open VMware Fusion Pro</li> <li>Click Create New if prompted</li> <li>Select Install from disc or image then press <code>Continue</code></li> <li>Drag the Ubuntu ISO file recently downloaded or click on <code>Use another disc or disc image...</code> to choose the Ubuntu ISO file downloaded</li> <li>Click Continue</li> <li>Follow the recommended setting options (Disk size: 50 GB)</li> <li>Finish setup</li> </ol>"},{"location":"Intro-to-ROS-2/vmware-ubuntu/#step-4-install-ubuntu","title":"Step 4: Install Ubuntu","text":""},{"location":"Intro-to-ROS-2/vmware-ubuntu/#windows-macos-intel-desktop-installer","title":"Windows &amp; macOS Intel (Desktop Installer)","text":"<ol> <li>Press <code>Ok</code> on the annoucement pop up notifications</li> <li>VM boots into Ubuntu installer</li> <li>Select Try or Install Ubuntu if prompted</li> <li>Choose language</li> <li>Keyboard layout \u2192 Continue</li> <li> <p>Updates &amp; other software:</p> </li> <li> <p>Normal installation</p> </li> <li>Download updates while installing Ubuntu</li> <li>Install third-party software ...</li> <li> <p>Installation type:</p> </li> <li> <p>Erase disk and install Ubuntu (This affects only the space you had given the virtual machine, not your entire computer)</p> </li> <li>Click on <code>Install Now</code> followed by <code>Continue</code> if promted to <code>Write the changes to disks?</code></li> <li>Select time zone</li> <li>Create user account</li> <li>Click Install</li> <li>Restart when prompted</li> </ol> <p>When asked to upgrade Ubuntu, such as going from the 22.04 installed to 24.04, it is imperative that you do not upgrade</p>"},{"location":"Intro-to-ROS-2/vmware-ubuntu/#macos-apple-silicon-server-installer","title":"macOS Apple Silicon (Server Installer)","text":"<ol> <li>Select Try or Install Ubuntu if prompted (use the arrow keys to change options and press <code>Enter</code> to select options)</li> <li>VM boots into text-based Ubuntu Server installer</li> <li> <p>Choose:</p> </li> <li> <p>Language</p> </li> <li>Keyboard layout</li> <li>If prompted to update the installer, feel free to do so</li> <li>Choose the base for the installation:<ul> <li>Ubuntu Server</li> <li>Search for third-party drivers</li> </ul> </li> <li> <p>Network:</p> </li> <li> <p>Accept default (automatic)</p> </li> <li> <p>Storage:</p> </li> <li> <p>Use entire disk (This affects only the space you had given the virtual machine, not your entire computer)</p> </li> <li>Accept defaults</li> <li>Click on <code>Continue</code> if prompted about destructive action on the disk (This affects only the space you had given the virtual machine, not your entire computer)</li> <li> <p>Profile setup:</p> </li> <li> <p>Username</p> </li> <li>Password</li> <li>Skip Ubuntu Pro</li> <li> <p>SSH:</p> </li> <li> <p>Optional (can skip)</p> </li> <li>Can skip any additional options</li> <li>Finish installation (might take a while)</li> <li>Reboot</li> <li>Press <code>Enter</code> if prompted to remove installation media</li> <li>Log in at the terminal</li> </ol> <p>At this point, no desktop is installed yet.</p>"},{"location":"Intro-to-ROS-2/vmware-ubuntu/#step-5-install-ubuntu-desktop-apple-silicon-only","title":"Step 5: Install Ubuntu Desktop (Apple Silicon Only)","text":"<p>After logging in, run:</p> <pre><code>sudo apt update\nsudo apt upgrade -y\nsudo apt install ubuntu-desktop -y\n</code></pre> <p>Press enter if asked <code>Which services should be restarted</code></p> <p>This may take several minutes.</p> <p>When finished:</p> <pre><code>sudo reboot\n</code></pre> <p>After reboot, the Ubuntu 22.04 Desktop (GNOME) will load.</p> <p>When asked to upgrade Ubuntu, such as going from the 22.04 installed to 24.04, it is imperative that you do not upgrade</p>"},{"location":"Intro-to-ROS-2/vmware-ubuntu/#step-6-install-vmware-tools-all-platforms","title":"Step 6: Install VMware Tools (All Platforms)","text":"<p>VMware Tools improves:</p> <ul> <li>Display resolution</li> <li>Mouse integration</li> <li>Performance</li> </ul>"},{"location":"Intro-to-ROS-2/vmware-ubuntu/#inside-the-ubuntu-vm","title":"Inside the Ubuntu VM","text":"<p>In Ubuntu, open a terminal (go on apps and look for <code>Terminal</code> and run:</p> <pre><code>sudo apt install open-vm-tools-desktop -y\nsudo reboot\n</code></pre>"},{"location":"Intro-to-ROS-2/vmware-ubuntu/#step-7-verification","title":"Step 7: Verification","text":"<p>After reboot, confirm:</p> <ul> <li>Ubuntu desktop loads successfully</li> <li>Screen resizes automatically</li> <li>Mouse moves smoothly in and out of the VM</li> <li>Feel free to play around with the display settings to optimize it</li> </ul>"},{"location":"Intro-to-ROS-2/vmware-ubuntu/#platform-summary-verified","title":"Platform Summary (Verified)","text":"Platform Ubuntu Method Windows Ubuntu 22.04 Desktop (amd64 ISO) macOS Intel Ubuntu 22.04 Desktop (amd64 ISO) macOS Apple Silicon Ubuntu 22.04 Server (ARM) + <code>ubuntu-desktop</code>"},{"location":"Intro-to-ROS-2/vmware-ubuntu/#notes","title":"Notes","text":"<ul> <li>Installing Ubuntu in a VM does not affect your real operating system</li> <li>Apple Silicon Macs require ARM-based Linux</li> <li>Using Ubuntu Server + desktop is fully supported and standard practice</li> </ul>"},{"location":"Intro-to-ROS-2/vmware-ubuntu/#verify-ubuntu-version","title":"Verify Ubuntu Version","text":"<p>Open a terminal in your Ubuntu 22 environment and run:</p> <pre><code>lsb_release -a\n</code></pre> <p>You should see information about which Ubuntu version you have installed</p>"},{"location":"Simulation-and-AEB-Systems/AEB-Systems/","title":"Automatic Emergency Braking (AEB) with iTTC","text":""},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#overview","title":"Overview","text":"<p>You will develop a safety node that prevents the race car from colliding with obstacles by implementing Automatic Emergency Braking (AEB) using Instantaneous Time to Collision (iTTC). This is a critical safety feature for autonomous racing vehicles.</p>"},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this, you will be able to: 1. Understand and implement Time to Collision (TTC) calculations 2. Work with LaserScan messages for obstacle detection 3. Process Odometry messages to extract vehicle velocity 4. Implement emergency braking logic using AckermannDriveStamped 5. Handle edge cases (inf, nan) in sensor data 6. Tune safety thresholds for reliable collision avoidance 7. Test safety systems in a simulated environment</p>"},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#prerequisites","title":"Prerequisites","text":"<p>Ensure ROS2 Humble is installed and sourced:</p> <pre><code>source /opt/ros/humble/setup.bash\n</code></pre>"},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#part-1-understanding-the-theory","title":"Part 1: Understanding the Theory","text":""},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#what-is-time-to-collision-ttc","title":"What is Time to Collision (TTC)?","text":"<p>Time to Collision (TTC) is the time it would take for a vehicle to collide with an obstacle if it maintains its current heading and velocity.</p> <p>Instantaneous Time to Collision (iTTC) is an approximation calculated from: - Current range measurements (from LiDAR) - Current velocity (from odometry)</p>"},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#the-ittc-formula","title":"The iTTC Formula","text":"<p>$$iTTC = \\frac{r}{{-\\dot{r}}_+}$$</p> <p>Where: - $r$ = instantaneous range measurement (distance to obstacle) - $\\dot{r}$ = range rate (rate of change of distance) - ${x}_+ = \\max(x, 0)$ (ensures we only consider approaching obstacles)</p>"},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#understanding-range-rate","title":"Understanding Range Rate","text":"<p>Range rate $\\dot{r}$ tells us how fast the distance to an obstacle is changing:</p> <ul> <li>Negative range rate: Distance is decreasing (approaching obstacle) \u2192 collision risk</li> <li>Positive range rate: Distance is increasing (moving away) \u2192 no collision risk</li> </ul> <p>Calculation Method 1 - Using Vehicle Velocity:</p> <p>For each LiDAR beam at angle $\\theta_i$:</p> <p>$$\\dot{r}_i = -v_x \\cos(\\theta_i)$$</p> <p>Where: - $v_x$ = vehicle's longitudinal velocity - $\\theta_i$ = angle of the LiDAR beam - Negative sign accounts for: approaching obstacle = shrinking range = negative rate</p> <p>Calculation Method 2 - Using Temporal Difference:</p> <p>$$\\dot{r}i = \\frac{r{current} - r_{previous}}{\\Delta t}$$</p> <p>For this lab, we'll use Method 1 (velocity projection method).</p>"},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#example-calculation","title":"Example Calculation","text":"<pre><code>Scenario: Car traveling at 2 m/s toward a wall 10m ahead\n\nBeam directly ahead (\u03b8 = 0\u00b0):\n- r = 10.0 m\n- v_x = 2.0 m/s\n- \u1e59 = -2.0 * cos(0\u00b0) = -2.0 m/s\n- iTTC = 10.0 / max(-(-2.0), 0) = 10.0 / 2.0 = 5.0 seconds\n\nBeam at 90\u00b0 to the side (\u03b8 = 90\u00b0):\n- r = 5.0 m\n- \u1e59 = -2.0 * cos(90\u00b0) = 0.0 m/s\n- iTTC = 5.0 / max(0.0, 0) \u2192 infinity (no collision risk)\n</code></pre>"},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#understanding-laserscan-message","title":"Understanding LaserScan Message","text":"<pre><code>LaserScan:\n  header:\n    stamp: Time of measurement\n    frame_id: \"ego_racecar/laser\"\n\n  angle_min: -2.35619  # Start angle (radians)\n  angle_max: 2.35619   # End angle (radians)\n  angle_increment: 0.00436  # Angular resolution\n\n  range_min: 0.0       # Minimum valid range\n  range_max: 30.0      # Maximum valid range\n\n  ranges: [5.2, 5.1, 5.0, ...]  # Array of range measurements\n</code></pre> <p>Key points: - <code>ranges</code> array is radially ordered from <code>angle_min</code> to <code>angle_max</code> - Each element corresponds to a specific angle (determined by using <code>angle_increment</code>) - Invalid measurements may be <code>inf</code> or <code>nan</code></p>"},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#part-2-setting-up-the-workspace","title":"Part 2: Setting Up the Workspace","text":""},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#step-21-create-package","title":"Step 2.1: Create Package","text":"<pre><code>cd ~/ros2_ws/src\nros2 pkg create safety_node --build-type ament_python \\\n  --dependencies rclpy sensor_msgs nav_msgs ackermann_msgs std_msgs\n</code></pre>"},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#step-22-create-directory-structure","title":"Step 2.2: Create Directory Structure","text":"<pre><code>cd safety_node\nmkdir -p launch config\n</code></pre> <p>Resulting structure:</p> <pre><code>safety_node/\n\u251c\u2500\u2500 safety_node/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 safety_node.py          # Main node (we'll create this)\n\u251c\u2500\u2500 launch/\n\u2502   \u2514\u2500\u2500 safety_node.launch.py   # Launch file (we'll create this)\n\u251c\u2500\u2500 config/\n\u2502   \u2514\u2500\u2500 safety_params.yaml      # Parameters (we'll create this)\n\u251c\u2500\u2500 package.xml\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 resource/\n</code></pre>"},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#step-23-check-packagexml","title":"Step 2.3: Check package.xml","text":"<p>Ensure your <code>package.xml</code> file has the necessary dependencies</p> <p>File: <code>~/ros2_ws/src/safety_node/package.xml</code></p> <pre><code>  ...\n  &lt;depend&gt;rclpy&lt;/depend&gt;\n  &lt;depend&gt;sensor_msgs&lt;/depend&gt;\n  &lt;depend&gt;nav_msgs&lt;/depend&gt;\n  &lt;depend&gt;ackermann_msgs&lt;/depend&gt;\n  &lt;depend&gt;std_msgs&lt;/depend&gt;\n  ...\n</code></pre>"},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#step-24-update-setuppy","title":"Step 2.4: Update setup.py","text":"<p>File: <code>~/ros2_ws/src/safety_node/setup.py</code></p> <pre><code>from setuptools import setup\nimport os # Added\nfrom glob import glob # Added\n\npackage_name = 'safety_node'\n\nsetup(\n    name=package_name,\n    version='1.0.0',\n    packages=[package_name],\n    data_files=[\n        ('share/ament_index/resource_index/packages',\n            ['resource/' + package_name]),\n        ('share/' + package_name, ['package.xml']),\n        # Include launch files\n        (os.path.join('share', package_name, 'launch'),\n            glob(os.path.join('launch', '*launch.[pxy][yma]*'))),\n        # Include config files\n        (os.path.join('share', package_name, 'config'),\n            glob(os.path.join('config', '*.yaml'))),\n    ],\n    install_requires=['setuptools'],\n    zip_safe=True,\n    maintainer='Student Name',\n    maintainer_email='student@example.com',\n    description='AEB safety node using iTTC',\n    license='MIT',\n    tests_require=['pytest'],\n    entry_points={\n        'console_scripts': [\n            'safety_node = safety_node.safety_node:main',\n        ],\n    },\n)\n</code></pre>"},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#part-3-implementing-the-safety-node-step-by-step","title":"Part 3: Implementing the Safety Node - Step by Step","text":""},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#step-31-create-basic-node-structure","title":"Step 3.1: Create Basic Node Structure","text":"<p>File: <code>~/ros2_ws/src/safety_node/safety_node/safety_node.py</code></p> <pre><code>#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\n\nimport numpy as np\nfrom sensor_msgs.msg import LaserScan\nfrom nav_msgs.msg import Odometry\nfrom ackermann_msgs.msg import AckermannDriveStamped, AckermannDrive\n\n\nclass SafetyNode(Node):\n    \"\"\"\n    The class that handles emergency braking.\n    \"\"\"\n    def __init__(self):\n        super().__init__('safety_node')\n\n        # Declare parameters\n        self.declare_parameter('ttc_threshold', 0.5)  # seconds\n        self.declare_parameter('speed_threshold', 0.1)  # m/s minimum speed to check\n\n        # Get parameters\n        self.ttc_threshold = self.get_parameter('ttc_threshold').value\n        self.speed_threshold = self.get_parameter('speed_threshold').value\n\n        # Initialize variables\n        self.speed = 0.0\n\n        # Create subscribers\n        self.scan_sub = self.create_subscription(\n            LaserScan,\n            '/scan',\n            self.scan_callback,\n            10)\n\n        self.odom_sub = self.create_subscription(\n            Odometry,\n            '/ego_racecar/odom',\n            self.odom_callback,\n            10)\n\n        # Create publisher for brake commands\n        self.brake_pub = self.create_publisher(\n            AckermannDriveStamped,\n            '/drive',\n            10)\n\n        self.get_logger().info('Safety Node initialized')\n        self.get_logger().info(f'TTC Threshold: {self.ttc_threshold} seconds')\n        self.get_logger().info(f'Speed Threshold: {self.speed_threshold} m/s')\n\n    def odom_callback(self, odom_msg):\n        \"\"\"\n        Update current speed from odometry\n        \"\"\"\n        # Extract longitudinal velocity (x component in vehicle frame)\n        self.speed = odom_msg.twist.twist.linear.x\n\n    def scan_callback(self, scan_msg):\n        \"\"\"\n        Process laser scan and trigger emergency brake if needed\n        \"\"\"\n        # TODO: Implement iTTC calculation and braking logic\n        pass\n\ndef main(args=None):\n    rclpy.init(args=args)\n    safety_node = SafetyNode()\n    try:\n        rclpy.spin(safety_node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        safety_node.destroy_node()\n        if rclpy.ok():\n           rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre> <p>Test this basic structure:</p> <pre><code>cd ~/ros2_ws\ncolcon build --packages-select safety_node --symlink-install\nsource install/setup.bash\nros2 run safety_node safety_node\n</code></pre> <p>Press Ctrl+C to stop. You should see the initialization messages.</p>"},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#step-32-implement-ittc-calculation","title":"Step 3.2: Implement iTTC Calculation","text":"<p>Now let's fill in the <code>scan_callback</code> with iTTC calculation:</p> <pre><code>def scan_callback(self, scan_msg):\n    \"\"\"\n    Process laser scan and trigger emergency brake if needed\n    \"\"\"\n    # Skip processing if car is nearly stationary\n    if abs(self.speed) &lt; self.speed_threshold:\n        return\n\n    # Extract scan data\n    ranges = np.array(scan_msg.ranges)\n\n    # Calculate angle for each beam\n    # angle_i = angle_min + i * angle_increment\n    num_beams = len(ranges)\n    angles = scan_msg.angle_min + np.arange(num_beams) * scan_msg.angle_increment\n\n    # Calculate range rate for each beam\n    # \u1e59 = -v_x * cos(\u03b8)\n    # Negative sign because approaching obstacle means decreasing range\n    range_rates = -self.speed * np.cos(angles)\n\n    # Calculate iTTC for each beam\n    # iTTC = r / max(-\u1e59, 0)\n    # We need -\u1e59 because we want positive values for approaching obstacles\n    # The max(..., 0) ensures we only consider negative range rates (approaching)\n\n    # Initialize iTTC array with infinity\n    ittc = np.full(num_beams, np.inf)\n\n    # Only calculate iTTC where range rate is negative (approaching obstacle)\n    approaching = range_rates &lt; 0\n\n    # Calculate iTTC for approaching obstacles\n    # iTTC = range / abs(range_rate)\n    ittc[approaching] = ranges[approaching] / np.abs(range_rates[approaching])\n\n    # Handle invalid measurements (inf, nan, out of range)\n    # Replace inf and nan with a large number to avoid triggering brake\n    ittc = np.nan_to_num(ittc, nan=np.inf, posinf=np.inf, neginf=np.inf)\n\n    # Also filter out measurements outside valid range\n    invalid_ranges = (ranges &lt; scan_msg.range_min) | (ranges &gt; scan_msg.range_max)\n    ittc[invalid_ranges] = np.inf\n\n    # Find minimum iTTC\n    min_ittc = np.min(ittc)\n\n    # Log for debugging\n    if min_ittc &lt; self.ttc_threshold:\n        self.get_logger().warn(\n            f'Collision imminent! Min iTTC: {min_ittc:.3f}s (threshold: {self.ttc_threshold}s)',\n            throttle_duration_sec=1.0)  # Throttle to avoid spam\n\n    # Trigger emergency brake if iTTC is below threshold\n    if min_ittc &lt; self.ttc_threshold:\n        self.publish_brake()\n\ndef publish_brake(self):\n    \"\"\"\n    Publish emergency brake command\n    \"\"\"\n    brake_msg = AckermannDriveStamped()\n    brake_msg.header.stamp = self.get_clock().now().to_msg()\n    brake_msg.header.frame_id = 'base_link'\n\n    # Set speed to 0 to brake\n    brake_msg.drive.speed = 0.0\n\n    self.brake_pub.publish(brake_msg)\n    self.get_logger().info('EMERGENCY BRAKE ACTIVATED!', throttle_duration_sec=1.0)\n</code></pre> <p>Complete safety_node.py at this stage:</p> <p>File: <code>~/ros2_ws/src/safety_node/safety_node/safety_node.py</code></p> <pre><code>#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\n\nimport numpy as np\nfrom sensor_msgs.msg import LaserScan\nfrom nav_msgs.msg import Odometry\nfrom ackermann_msgs.msg import AckermannDriveStamped, AckermannDrive\n\n\nclass SafetyNode(Node):\n    \"\"\"\n    The class that handles emergency braking using iTTC.\n    \"\"\"\n    def __init__(self):\n        super().__init__('safety_node')\n\n        # Declare parameters\n        self.declare_parameter('ttc_threshold', 0.5)\n        self.declare_parameter('speed_threshold', 0.1)\n\n        # Get parameters\n        self.ttc_threshold = self.get_parameter('ttc_threshold').value\n        self.speed_threshold = self.get_parameter('speed_threshold').value\n\n        # Initialize variables\n        self.speed = 0.0\n\n        # Create subscribers\n        self.scan_sub = self.create_subscription(\n            LaserScan,\n            '/scan',\n            self.scan_callback,\n            10)\n\n        self.odom_sub = self.create_subscription(\n            Odometry,\n            '/ego_racecar/odom',\n            self.odom_callback,\n            10)\n\n        # Create publisher for brake commands\n        self.brake_pub = self.create_publisher(\n            AckermannDriveStamped,\n            '/drive',\n            10)\n\n        self.get_logger().info('='*50)\n        self.get_logger().info('Safety Node initialized')\n        self.get_logger().info(f'TTC Threshold: {self.ttc_threshold} seconds')\n        self.get_logger().info(f'Speed Threshold: {self.speed_threshold} m/s')\n        self.get_logger().info('='*50)\n\n    def odom_callback(self, odom_msg):\n        \"\"\"\n        Update current speed from odometry.\n        The x component of linear velocity is the longitudinal speed.\n        \"\"\"\n        self.speed = odom_msg.twist.twist.linear.x\n\n    def scan_callback(self, scan_msg):\n        \"\"\"\n        Process laser scan and trigger emergency brake if needed.\n        Calculates iTTC for all beams and brakes if minimum is below threshold.\n        \"\"\"\n        # Skip processing if car is nearly stationary\n        if abs(self.speed) &lt; self.speed_threshold:\n            return\n\n        # Extract scan data\n        ranges = np.array(scan_msg.ranges)\n\n        # Calculate angle for each beam\n        num_beams = len(ranges)\n        angles = scan_msg.angle_min + np.arange(num_beams) * scan_msg.angle_increment\n\n        # Calculate range rate for each beam\n        # \u1e59 = -v_x * cos(\u03b8)\n        range_rates = -self.speed * np.cos(angles)\n\n        # Initialize iTTC array with infinity\n        ittc = np.full(num_beams, np.inf)\n\n        # Only calculate iTTC where range rate is negative (approaching)\n        approaching = range_rates &lt; 0\n\n        # Calculate iTTC: iTTC = r / |\u1e59| for approaching obstacles\n        ittc[approaching] = ranges[approaching] / np.abs(range_rates[approaching])\n\n        # Handle invalid measurements\n        ittc = np.nan_to_num(ittc, nan=np.inf, posinf=np.inf, neginf=np.inf)\n\n        # Filter out measurements outside valid range\n        invalid_ranges = (ranges &lt; scan_msg.range_min) | (ranges &gt; scan_msg.range_max)\n        ittc[invalid_ranges] = np.inf\n\n        # Find minimum iTTC\n        min_ittc = np.min(ittc)\n\n        # Debug logging\n        if min_ittc &lt; self.ttc_threshold:\n            min_idx = np.argmin(ittc)\n            min_angle = angles[min_idx]\n            min_range = ranges[min_idx]\n\n            self.get_logger().warn(\n                f'Collision Warning! iTTC: {min_ittc:.3f}s | '\n                f'Range: {min_range:.2f}m | Angle: {np.degrees(min_angle):.1f}\u00b0',\n                throttle_duration_sec=0.5)\n\n        # Trigger emergency brake if iTTC is below threshold\n        if min_ittc &lt; self.ttc_threshold:\n            self.publish_brake()\n\n    def publish_brake(self):\n        \"\"\"\n        Publish emergency brake command (speed = 0).\n        \"\"\"\n        brake_msg = AckermannDriveStamped()\n        brake_msg.header.stamp = self.get_clock().now().to_msg()\n        brake_msg.header.frame_id = 'base_link'\n        brake_msg.drive.speed = 0.0\n\n        self.brake_pub.publish(brake_msg)\n        self.get_logger().info(\n            '\ud83d\uded1 EMERGENCY BRAKE ACTIVATED! \ud83d\uded1',\n            throttle_duration_sec=1.0)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    safety_node = SafetyNode()\n    try:\n        rclpy.spin(safety_node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        safety_node.destroy_node()\n        if rclpy.ok():\n           rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#step-33-create-parameter-configuration-file","title":"Step 3.3: Create Parameter Configuration File","text":"<p>File: <code>~/ros2_ws/src/safety_node/config/safety_params.yaml</code></p> <pre><code># Safety Node Parameters\n\nsafety_node:\n  ros__parameters:\n    # Time to Collision threshold (seconds)\n    # Lower values = more aggressive braking\n    # Higher values = more conservative, may brake unnecessarily\n    ttc_threshold: 0.5\n\n    # Minimum speed to activate safety checks (m/s)\n    # Below this speed, AEB is disabled to avoid false positives when stationary\n    speed_threshold: 0.1\n</code></pre>"},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#step-34-create-launch-file","title":"Step 3.4: Create Launch File","text":"<p>File: <code>~/ros2_ws/src/safety_node/launch/safety_node.launch.py</code></p> <pre><code>#!/usr/bin/env python3\n\nimport os\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\nfrom launch.actions import DeclareLaunchArgument\nfrom launch.substitutions import LaunchConfiguration\nfrom ament_index_python.packages import get_package_share_directory\n\n\ndef generate_launch_description():\n    \"\"\"\n    Launch the safety node with parameters\n    \"\"\"\n\n    # Get package directory\n    pkg_dir = get_package_share_directory('safety_node')\n\n    # Path to parameter file\n    params_file = os.path.join(pkg_dir, 'config', 'safety_params.yaml')\n\n    # Declare launch arguments\n    ttc_threshold_arg = DeclareLaunchArgument(\n        'ttc_threshold',\n        default_value='0.5',\n        description='Time to Collision threshold in seconds'\n    )\n\n    speed_threshold_arg = DeclareLaunchArgument(\n        'speed_threshold',\n        default_value='0.1',\n        description='Minimum speed to activate AEB (m/s)'\n    )\n\n    # Safety node\n    safety_node = Node(\n        package='safety_node',\n        executable='safety_node',\n        name='safety_node',\n        output='screen',\n        emulate_tty=True,\n        parameters=[\n            params_file,\n            {\n                'ttc_threshold': LaunchConfiguration('ttc_threshold'),\n                'speed_threshold': LaunchConfiguration('speed_threshold'),\n            }\n        ]\n    )\n\n    return LaunchDescription([\n        ttc_threshold_arg,\n        speed_threshold_arg,\n        safety_node,\n    ])\n</code></pre>"},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#step-35-build-and-test","title":"Step 3.5: Build and Test","text":"<pre><code>cd ~/ros2_ws\ncolcon build --packages-select safety_node\nsource install/setup.bash\n</code></pre> <p>Test the node:</p> <pre><code>ros2 launch safety_node safety_node.launch.py\n</code></pre>"},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#part-4-testing-procedure","title":"Part 4: Testing Procedure","text":"<ol> <li> <p>Start all nodes (simulator, safety, teleop, anything else that is needed)</p> </li> <li> <p>In simulator, use <code>2D Pose Estimate tool</code> to position and orient the car. Click somewhere on the map, and drag for direction.</p> </li> <li> <p>Drive toward a wall using keyboard:</p> </li> <li> <p>Observe safety node behavior:</p> </li> <li>Watch terminal for iTTC warnings</li> <li>Car should automatically brake before hitting wall</li> <li> <p>Test at different speeds</p> </li> <li> <p>Experiment with parameters:    ```bash    # More aggressive braking    ros2 launch safety_node safety_node.launch.py ttc_threshold:=1.0</p> </li> </ol> <p># Less aggressive    ros2 launch safety_node safety_node.launch.py ttc_threshold:=0.3    ```</p> <p>Note that the simulation is in development and does not always work as expected</p>"},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#part-5-advanced-features-and-tuning","title":"Part 5: Advanced Features and Tuning","text":""},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#step-51-add-safety-regions","title":"Step 5.1: Add Safety Regions","text":"<p>Modify to have different thresholds for different angular regions:</p> <pre><code>def scan_callback(self, scan_msg):\n    # ... existing code ...\n\n    # Define safety regions (in radians)\n    front_region = (-0.5, 0.5)  # \u00b130 degrees\n    side_region_threshold = 0.3  # More permissive for sides\n\n    # Apply region-specific thresholds\n    front_mask = (angles &gt;= front_region[0]) &amp; (angles &lt;= front_region[1])\n\n    # Check front region with stricter threshold\n    if np.any(ittc[front_mask] &lt; self.ttc_threshold):\n        self.publish_brake()\n        return\n\n    # Check sides with more permissive threshold\n    if np.min(ittc) &lt; side_region_threshold:\n        self.publish_brake()\n</code></pre>"},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#step-52-add-filtering-for-false-positives","title":"Step 5.2: Add Filtering for False Positives","text":"<pre><code>def __init__(self):\n    # ... existing code ...\n    self.brake_count = 0\n    self.brake_threshold_count = 3  # Must trigger 3 times in a row\n\ndef scan_callback(self, scan_msg):\n    # ... existing iTTC calculation ...\n\n    if min_ittc &lt; self.ttc_threshold:\n        self.brake_count += 1\n    else:\n        self.brake_count = 0\n\n    # Only brake if consistently detecting collision\n    if self.brake_count &gt;= self.brake_threshold_count:\n        self.publish_brake()\n</code></pre>"},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#summary","title":"Summary","text":""},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#what-we-learned","title":"What We Learned:","text":"<ol> <li>iTTC Theory:</li> <li>Time to Collision concept</li> <li>Range rate calculation</li> <li> <p>Projection of velocity onto scan beams</p> </li> <li> <p>ROS2 Message Types:</p> </li> <li><code>LaserScan</code> - LiDAR data structure</li> <li><code>Odometry</code> - Vehicle state information</li> <li> <p><code>AckermannDriveStamped</code> - Vehicle control commands</p> </li> <li> <p>Safety System Design:</p> </li> <li>Real-time obstacle detection</li> <li>Emergency braking logic</li> <li> <p>Handling edge cases (inf, nan)</p> </li> <li> <p>Parameter Tuning:</p> </li> <li>TTC threshold selection</li> <li>Speed threshold configuration</li> <li> <p>Region-specific safety zones</p> </li> <li> <p>Testing and Validation:</p> </li> <li>Simulator-based testing</li> <li>Visualization with RViz</li> <li>Debug monitoring</li> </ol>"},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#key-takeaways-for-autonomous-racing","title":"Key Takeaways for Autonomous Racing:","text":"<ul> <li>Safety is paramount - AEB is a last-resort safety net</li> <li>Tuning is critical - Balance between safety and performance</li> <li>Real-time constraints - Must process scans quickly</li> <li>Robust handling - Must deal with sensor noise and errors</li> <li>Layered safety - AEB complements higher-level planning</li> </ul>"},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#practice","title":"Practice","text":""},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#automatic-emergency-braking-aeb-experimentation-and-analysis","title":"Automatic Emergency Braking (AEB) Experimentation and Analysis","text":""},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#objective","title":"Objective","text":"<p>Demonstrate that your Safety Node using Instantaneous Time to Collision (iTTC) can compute iTTC from /scan and /ego_racecar/odom, and stop the vehicle before collision.</p>"},{"location":"Simulation-and-AEB-Systems/AEB-Systems/#overview_1","title":"Overview","text":"<p>You will:</p> <ol> <li>Run the simulator with keyboard teleop and your safety node.</li> <li>Drive the vehicle toward a wall.</li> <li>Increase speed gradually.</li> <li>Observe when braking occurs.</li> </ol>"},{"location":"Simulation-and-AEB-Systems/F1tenthGymROS-Install/","title":"F1TENTH Gym ROS Setup Guide","text":"<p>This guide will walk you through the steps to install the F1TENTH Gym environment (a Python-based simulation library) and integrate the ROS2 communication bridge. These instructions apply to both ROS 2 Humble running on Ubuntu 22.04 (either natively or through a virtual machine).</p>"},{"location":"Simulation-and-AEB-Systems/F1tenthGymROS-Install/#1-update-system-and-install-dependencies","title":"1. Update System and Install Dependencies","text":"<p>Before starting, ensure your system packages are up-to-date and that Python3\u2019s <code>pip</code> is installed:</p> <pre><code>sudo apt update\nsudo apt install python3-pip\n</code></pre>"},{"location":"Simulation-and-AEB-Systems/F1tenthGymROS-Install/#2-clone-and-install-f1tenth-gym","title":"2. Clone and Install F1TENTH Gym","text":"<p>Navigate to your home directory (or any location of your choice) and clone the F1TENTH Gym repository:</p> <pre><code>cd $HOME\ngit clone https://github.com/f1tenth/f1tenth_gym\ncd f1tenth_gym &amp;&amp; pip3 install -e .\n</code></pre> <p>Tip: Installing in editable mode (<code>-e</code>) allows you to update the package locally without reinstalling it.</p>"},{"location":"Simulation-and-AEB-Systems/F1tenthGymROS-Install/#3-set-up-your-ros2-workspace","title":"3. Set Up Your ROS2 Workspace","text":"<p>Create a new workspace for your ROS2 simulation:</p> <pre><code>cd $HOME\nmkdir -p sim_ws/src\n</code></pre> <p>Navigate into the <code>src</code> directory and clone the ROS2 communication bridge repository:</p> <pre><code>cd $HOME/sim_ws/src\ngit clone https://github.com/f1tenth/f1tenth_gym_ros\n</code></pre>"},{"location":"Simulation-and-AEB-Systems/F1tenthGymROS-Install/#4-configure-the-simulation","title":"4. Configure the Simulation","text":"<p>The F1TENTH Gym simulation uses a YAML configuration file to define parameters such as the map file path and the number of agents. Here\u2019s how to update it:</p> <ol> <li>Open the <code>sim.yaml</code> configuration file (located under <code>f1tenth_gym_ros/config/</code>) using your preferred text editor:</li> </ol> <p><code>bash    nano $HOME/sim_ws/src/f1tenth_gym_ros/config/sim.yaml</code></p> <ol> <li>Locate the <code>map_path</code> parameter and update it with the full path to the map file on your system:</li> </ol> <p><code>yaml    map_path: \"&lt;your_home_dir&gt;/sim_ws/src/f1tenth_gym_ros/maps/levine\"</code></p> <p>Replace <code>&lt;your_home_dir&gt;</code> with your absolute home directory path. For example:</p> <p><code>yaml        map_path: '/home/israel/sim_ws/src/f1tenth_gym_ros/maps/levine'</code></p> <p>Tip: You can use <code>pwd</code> to output the path of your current directory.</p>"},{"location":"Simulation-and-AEB-Systems/F1tenthGymROS-Install/#5-initialize-rosdep-and-install-ros2-dependencies","title":"5. Initialize rosdep and Install ROS2 Dependencies","text":""},{"location":"Simulation-and-AEB-Systems/F1tenthGymROS-Install/#initialize-rosdep","title":"Initialize rosdep","text":"<p>First, initialize rosdep (if not already initialized):</p> <pre><code>sudo rosdep init\nrosdep update --include-eol-distros\n</code></pre>"},{"location":"Simulation-and-AEB-Systems/F1tenthGymROS-Install/#install-ros2-dependencies","title":"Install ROS2 dependencies","text":"<p>Move to your ROS2 workspace directory and install dependencies using rosdep. The command differs based on the ROS2 distribution:</p> <pre><code>cd $HOME/sim_ws\nrosdep install -i --from-path src --rosdistro humble -y\n</code></pre> <p>Tip: Ensure that you have sourced your ROS2 environment setup before running <code>rosdep</code>: <code>bash source /opt/ros/humble/setup.bash</code></p>"},{"location":"Simulation-and-AEB-Systems/F1tenthGymROS-Install/#6-build-the-ros2-workspace","title":"6. Build the ROS2 Workspace","text":"<p>Once dependencies are installed, build your workspace with colcon:</p> <pre><code>colcon build\n</code></pre>"},{"location":"Simulation-and-AEB-Systems/F1tenthGymROS-Install/#7-launch-the-simulation","title":"7. Launch the Simulation","text":"<p>After building the workspace, launch the simulation. Open a new terminal (or use a terminal multiplexer like tmux) and source both your ROS2 setup and local workspace setup:</p> <pre><code>source /opt/ros/humble/setup.bash\nsource $HOME/sim_ws/install/local_setup.bash\n</code></pre> <p>Now, launch the simulation bridge with:</p> <pre><code>ros2 launch f1tenth_gym_ros gym_bridge_launch.py\n</code></pre> <p>You should see the simulation window (or RViz visualization) displaying the simulation environment.</p>"},{"location":"Simulation-and-AEB-Systems/F1tenthGymROS-Install/#temporary-fix-for-gym_bridge-crashing","title":"Temporary fix for gym_bridge crashing","text":"<p>If you do not see the vehicle, the laser scan points, and keyboard teleop won't work either, run the following command:</p> <pre><code>python3 -m pip install --user -U \"coverage&gt;=7.6.1\"\n</code></pre>"},{"location":"Simulation-and-AEB-Systems/F1tenthGymROS-Install/#might-need-to-wait-a-few-seconds-for-everything-to-load","title":"&gt; might need to wait a few seconds for everything to load","text":""},{"location":"Simulation-and-AEB-Systems/F1tenthGymROS-Install/#8-configuring-the-simulation","title":"8. Configuring the Simulation","text":"<p>The simulation configuration is managed through the <code>sim.yaml</code> file, located at <code>f1tenth_gym_ros/config/sim.yaml</code>. Here are the key parameters you can adjust:</p> <ul> <li><code>map_path</code>: The full path to your map file (ROS convention: map image and YAML file should have the same name and be in the same directory).</li> <li><code>num_agent</code>: Set this to <code>1</code> for a single agent or <code>2</code> for a two-agent race.</li> <li>Starting Pose: Adjust the <code>ego</code> and <code>opponent</code> starting poses, defined in the global map coordinate frame.</li> </ul> <p>After making changes to the configuration, rebuild the workspace with <code>colcon build</code> to reflect these changes in the container.</p>"},{"location":"Simulation-and-AEB-Systems/F1tenthGymROS-Install/#9-some-topics-published-by-the-simulation","title":"9. Some Topics Published by the Simulation","text":""},{"location":"Simulation-and-AEB-Systems/F1tenthGymROS-Install/#in-single-agent-mode-topics-published","title":"In Single-Agent Mode (Topics Published)","text":"<ul> <li><code>/scan</code>: The ego agent's laser scan.</li> <li><code>/ego_racecar/odom</code>: The ego agent's odometry.</li> <li><code>/map</code>: The map of the environment.</li> </ul> <p>A TF tree is maintained for transformation frames.</p>"},{"location":"Simulation-and-AEB-Systems/F1tenthGymROS-Install/#in-two-agent-mode-topics-published","title":"In Two-Agent Mode (Topics Published)","text":"<p>In addition to the topics above, these additional topics are published:</p> <ul> <li><code>/opp_scan</code>: The opponent agent's laser scan.</li> <li><code>/ego_racecar/opp_odom</code>: The opponent agent's odometry (for ego agent's planner).</li> <li><code>/opp_racecar/odom</code>: The opponent agent's odometry.</li> <li><code>/opp_racecar/opp_odom</code>: The ego agent's odometry (for opponent agent's planner).</li> </ul>"},{"location":"Simulation-and-AEB-Systems/F1tenthGymROS-Install/#10-topics-subscribed-by-the-simulation","title":"10. Topics Subscribed by the Simulation","text":""},{"location":"Simulation-and-AEB-Systems/F1tenthGymROS-Install/#in-single-agent-mode-topics-subscribed","title":"In Single-Agent Mode (Topics Subscribed)","text":"<ul> <li><code>/drive</code>: The ego agent's drive command (via <code>AckermannDriveStamped</code> messages).</li> <li><code>/initialpose</code>: The topic for resetting the ego's pose via RViz's 2D Pose Estimate tool.</li> </ul>"},{"location":"Simulation-and-AEB-Systems/F1tenthGymROS-Install/#in-two-agent-mode-topics-subscribed","title":"In Two-Agent Mode (Topics Subscribed)","text":"<ul> <li>In addition to the topics listed above, the following topics are available:</li> <li><code>/opp_drive</code>: The opponent agent's drive command (via <code>AckermannDriveStamped</code> messages). You need to publish to both the ego\u2019s and opponent\u2019s drive topics for both vehicles to move.</li> <li><code>/goal_pose</code>: The topic for resetting the opponent agent's pose via RViz's 2D Goal Pose tool.</li> </ul>"},{"location":"Simulation-and-AEB-Systems/F1tenthGymROS-Install/#11-enabling-keyboard-teleoperation","title":"11. Enabling Keyboard Teleoperation","text":"<p>The teleop_twist_keyboard package is included as part of the simulation's dependencies. To enable keyboard teleoperation, set <code>kb_teleop</code> to <code>True</code> in the <code>sim.yaml</code> configuration file.</p> <p>After launching the simulation, in another terminal, run:</p> <pre><code>ros2 run teleop_twist_keyboard teleop_twist_keyboard\n</code></pre> <p>In the terminal window running the teleop node:</p> <ul> <li>Press <code>i</code> to move forward.</li> <li>Press <code>u</code> and <code>o</code> to move forward and turn.</li> <li>Press <code>,</code> to move backward.</li> <li>Press <code>m</code> and <code>.</code> to move backward and turn.</li> <li>Press <code>k</code> to stop.</li> </ul>"},{"location":"Simulation-and-AEB-Systems/F1tenthGymROS-Install/#12-developing-your-own-agent-in-ros2","title":"12. Developing Your Own Agent in ROS2","text":"<p>You have two options to develop and launch your own agent to control the vehicles:</p> <ol> <li> <p>Create a new package in the existing ROS2 workspace:    Create your package in the <code>/sim_ws</code> workspace. After launching the simulation, launch your agent node in another terminal.</p> </li> <li> <p>Create a new container for your agent node:    Create a separate workspace for your agent node. Ensure both the simulation and agent workspace are on the same network to enable communication.</p> </li> </ol>"}]}